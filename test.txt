#include "mainwindow.h"
#include "ui_mainwindow.h"
#include <opencv4/opencv2/opencv.hpp>
#include <opencv4/opencv2/core.hpp>
#include <opencv4/opencv2/core/mat.hpp>
#include <opencv4/opencv2/calib3d/calib3d.hpp>
#include <opencv4/opencv2/highgui/highgui.hpp>
#include <opencv4/opencv2/highgui/highgui_c.h>
#include <opencv4/opencv2/imgproc/imgproc.hpp>
#include <stdio.h>
#include <iostream>
#include <vector>
#include <chrono>

//So that opevCV functions can be used directly (without a cv:: or std everytime)
using namespace std;
using namespace cv;

using std::chrono::high_resolution_clock;
using std::chrono::duration_cast;
using std::chrono::milliseconds;

//https://learnopencv.com/camera-calibration-using-opencv/
MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
{
    ui->setupUi(this);



    auto t1 = high_resolution_clock::now();



    // Defining the dimensions of checkerboard
    int CHECKERBOARD[2]{8,6};

    // Creating vector to store vectors of 3D points for each checkerboard image
    vector<vector<Point3f> > objPoints;

    // Creating vector to store vectors of 2D points for each checkerboard image
    vector<vector<Point2f> > imgPoints;


    // Defining the world coordinates for 3D points
    vector<Point3f> objp;
    for(int i{0}; i<CHECKERBOARD[1]; i++)
      {
        for(int j{0}; j<CHECKERBOARD[0]; j++)
          objp.push_back(Point3f(j,i,0));
      }


    // Extracting path of individual image stored in a given directory
    vector<String> images;
    // Path of the folder containing checkerboard images (Does not take gif)
    string path = "/home/ccs/Pictures/*.png";
    qDebug("path ok ");
    glob(path, images);


    Mat frame, gray;
    // vector to store the pixel coordinates of detected checker board corners
    vector<Point2f> corner_pts;
    bool success;

    // Looping over all the images in the directory
    for(int i{0}; i<images.size(); i++)
      {
        qDebug("For image %d", i+1);
        frame = imread(images[i]);

        //Creating gray scal cpy
        cvtColor(frame,gray,COLOR_BGR2GRAY);
        namedWindow("Gray", CV_WINDOW_KEEPRATIO);
        resizeWindow("Gray", 500,500);
        imshow("Gray",gray);


        // Finding checker board corners
        success = findChessboardCorners(gray, Size(CHECKERBOARD[0], CHECKERBOARD[1]), corner_pts);//, CV_CALIB_CB_ADAPTIVE_THRESH | CV_CALIB_CB_FAST_CHECK | CV_CALIB_CB_NORMALIZE_IMAGE);


        if(success)
        {
          qDebug("Success, Chessboard found %d", i+1);

          TermCriteria criteria(CV_TERMCRIT_EPS | CV_TERMCRIT_ITER, 30, 0.001);

          // refining pixel coordinates for given 2d points.
          cornerSubPix(gray,corner_pts,Size(11,11), Size(-1,-1),criteria);

          // Displaying the detected corner points on the checker board
          drawChessboardCorners(frame, Size(CHECKERBOARD[0], CHECKERBOARD[1]), corner_pts, success);

          objPoints.push_back(objp);
          imgPoints.push_back(corner_pts);

        }
        else {
            qDebug("Failed image %d", i+1);
        }
        namedWindow("Image", CV_WINDOW_KEEPRATIO);
        resizeWindow("Image", 500,500);
        imshow("Image",frame);

        waitKey(0);

      }

    destroyAllWindows();




    //Camera calibration
    Mat cameraMatrix,distCoeffs,R,T;
    calibrateCamera(objPoints, imgPoints, Size(gray.rows,gray.cols), cameraMatrix, distCoeffs, R, T);

    //Fish-eye calibration
    //int flags = fisheye::CALIB_RECOMPUTE_EXTRINSIC|fisheye::CALIB_FIX_SKEW;
    //TermCriteria criteria(TermCriteria::EPS|TermCriteria::MAX_ITER, 30, 1e-6);
    //fisheye::calibrate(objPoints, imgPoints, Size(gray.rows,gray.cols), cameraMatrix, distCoeffs, R, T, flags, criteria);

    //vector<vector<Point2f> > perViewErrors;
    //calibrateCamera(objPoints, imgPoints, Size(gray.rows,gray.cols), cameraMatrix, distCoeffs, R, T, noArray(), noArray(), perViewErrors, 0);


    //Print camera parameters
    cout << "cameraMatrix : " << cameraMatrix << endl;
    cout << "distCoeffs : " << distCoeffs << endl;
    cout << "Rotation vector : " << R << endl;
    cout << "Translation vector : " << T << endl;



    //Undistorted image
    Mat distortedIMG, undistortedIMG;
    distortedIMG = imread(images[0]);
    undistort(distortedIMG, undistortedIMG, cameraMatrix, distCoeffs);

    namedWindow("Distorted", CV_WINDOW_KEEPRATIO);
    resizeWindow("Distorted", 500,500);
    imshow("Distorted",distortedIMG);

    namedWindow("Undistorted", CV_WINDOW_KEEPRATIO);
    resizeWindow("Undistorted", 500,500);
    imshow("Undistorted",undistortedIMG);



    //Stop clock
    auto t2 = high_resolution_clock::now();
    /* Getting number of milliseconds as an integer. */
    auto ms_int = duration_cast<milliseconds>(t2 - t1);
    cout << ms_int.count() << "ms\n" << endl;


    // Re-projection error(Shows how good the calibration is, optimal == 0)
    //float meanError = 0;
    //std::vector<cv::Point2f> imagePoints2;

    // Print std::vector<std::vector<cv::Point3f> (Vector of vectors)
    /*
    for (int i = 0; i < objpoints.size(); i++) {
        std::cout << "Vector:  " << i << std::endl;
            for (int j = 0; j < objpoints[i].size(); j++)
                std::cout << " " << objpoints[i][j] << std::endl;
        }
    */

    //for (int i = {0}; i < objPoints.size(); ++i) {
        //qDebug("obj: %d", i+1);
        //std::cout << "Test objpoints : " << objpoints[i] << std::endl;
        //cv::projectPoints (objPoints[i], (R.row(i)).t(), (T.row(i)).t(), cameraMatrix, distCoeffs.t(), cv::noArray(), imagePoints2);
        
        //error = cv.norm(imgpoints[i], imgpoints2, cv.NORM_L2)/len(imgpoints2)
        // cv::NORM_L2 
        //mean_error += error

    //}





























CONFIG += c++11

INCLUDEPATH += /usr/local/include/opencv4

LIBS += -lopencv_core -lopencv_imgcodecs -lopencv_highgui -lopencv_calib3d -lopencv_imgproc

SOURCES += \